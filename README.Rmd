---
title: "GDUM: Simultaneusly estimating community dissimilarity and uniqueness"
output: github_document
---

# Fitting GDUMs in `greta`

Here we show how to fit and inspect Generalized Dissimilarity Uniqueness Models (DGUM) using `greta`. We provide some helper functions to construct the models and generate predictions.This scripts assumes that a folder named `functions` exists in the working directory with the helper functions provided [here](https://github.com/dhercar/GDUM/tree/main/Functions). 

```{r, echo = TRUE, warning=FALSE, message=FALSE, results='hide'}
# Load functions
dir <- './functions/'
files.sources = list.files(dir)
sapply(paste0(dir,files.sources), source)
```

Some other necessary packages: 
```{r, echo = TRUE, warning=FALSE, message=FALSE, results='hide'}
library(greta)
library(coda)
library(bayesplot)
library(ggplot2)
library(tidyverse)
```

Note that the package `greta` requires some additional dependencies. Please check [greta-stats.org/](https://greta-stats.org/) for more information. 

## Case-study: Fish from the doubs river

We will use the [doubs dataset](https://www.davidzeleny.net/anadat-r/doku.php/en:data:doubs) as an example. The dataset contains abundances of fish species along the Doubs river. 

```{r, echo = TRUE, warning=FALSE, message=FALSE, results='hide'}
# Load datasets
doubs.spe <- read.csv('https://raw.githubusercontent.com/zdealveindy/anadat-r/master/data/DoubsSpe.csv', 
                      row.names = 1)
doubs.env <- read.csv('https://raw.githubusercontent.com/zdealveindy/anadat-r/master/data/DoubsEnv.csv', 
                      row.names = 1)
doubs.spa <- read.csv('https://raw.githubusercontent.com/zdealveindy/anadat-r/master/data/DoubsSpa.csv', 
                      row.names = 1)
```
doubs.spe
```{r, echo = FALSE}
kableExtra::kable(head(doubs.spe))
```
doubs.env
```{r, echo = FALSE}
kableExtra::kable(head(doubs.env))
```

doubs.spa
```{r, echo = FALSE}
kableExtra::kable(head(doubs.spa))
```

## Preparing data

We provide two functions to help formatting the data: `make_x_df()` and `make_y_df()`.  `make_x_df()` generates a matrix of pairwise distances for the variables of interest:

```{r}
X <- make_x_df(env = doubs.env, 
               scale = FALSE, # Whether variables should be scaled prior to computing distances
               method = 'euclidean', # Method passed to `dist`
               collapse = FALSE)  # Whether environmental variables should be collapsed into a single environmental distance

kableExtra::kable(head(X))
```

`make_y_df()` computes pairwise dissimilarities and returns a data frame in long format. Different options are available, including: 

- Methods available in `vegan::vegdist()`: `make_y_df(data, method = 'bray')`
- Numerator-denominator versions of Sørensen-Dice and Jaccard indices: `make_y_df(data, method = 'jaccard', num_den = TRUE)`
- Full matrix of shared and unshared species between samples: `make_y_df(data, method = 'abcd')`

We generate different matrices to show how GDUM can handle different response variables.

```{r}
Y_bin <- make_y_df(com = doubs.spe, method = 'sorensen', num_den = TRUE)
kableExtra::kable(head(Y_bin))
Y_bray <- make_y_df(com = doubs.spe, trans = log1p)
kableExtra::kable(head(Y_bray))
```
Outputs from `make_y_df()` and `make_x_df()` contain two columns that indicate which pair of samples are compared in each row: `s1` and `s2`. These columns should be consistent across datasets.

```{r}
all.equal(X[,c('s1','s2')],Y_bin[,c('s1','s2')])
```

## Fitting models

We provide a function `fit_gdum()` to help built GDUMs in `greta`. By deafault, `fit_gdum()` uses uninformative priors that expect predictors to be scaled. In this example, we use nitrogen (nit) concentration as a pairwise predictor and pH as a site-level effect. 

```{r}
X$s_dist_nit <- scale(X$dist_nit)
doubs.env$s_pH <- scale(doubs.env$pH)
```

In addition, a design matrix `D` indicating which sites are compared in each row is required to match dissimilarities with pairwise- and site-level predictor. 

```{r}
D <- X[,c('s1','s2')]
```

### Gaussian distribution

```{r, echo = TRUE, warning=FALSE, message=FALSE, results='hide'}
m_gaus <- fit_gdum(Y = Y_bray[,3], # Dissimilarities
         W = doubs.env, # Site level predictors
         X = X, # Pairwise level predictors
         D = D, # Design matrix 
         family = 'gaussian',
         link = 'identity',
         diss_formula = ~ s_dist_nit, # pairwise level formula 
         site_formula = ~ s_pH, # site level formula
         warmup = 2000, # mcmc warm up
         n_samples = 4000, # samples taken after warm up
         Lmin = 15, 
         Lmax = 20)
```

`Lmin` and `Lmax` are parameters passed to `greta::hmc()`. See [greta-stats.org/reference/samplers](https://greta-stats.org/reference/samplers) for more information.

We can explore MCMC chains using functions in `coda` and `bayesplot`. MCMC chains are in `m_gaus$draws`. 

```{r}
bayesplot::mcmc_trace(m_gaus$draws, regex_pars = c('alpha','beta','lambda'))
```

- `alpha` is the global intercept
- `beta_X` are the coefficients for pairwise-level predictors
- `labmda_X` are the coefficients for site-level predictors

In addition, `coda::gelman.diag()` can be used to compute the [Gelman-Rubin](https://en.wikipedia.org/wiki/Gelman-Rubin_statistic) statistic

```{r}
coda::gelman.diag(m_gaus$draws)
```

In our case, all values are relatively small ($\geq 1.01$) indicating that chains have succesfully converged. 

The `summary` of the draws provides the estimated value of each model parameter and credibility intervals
```{r}
summary(m_gaus$draws)[[1]][1:5,]
```

- `sigma` is the standard deviation of the normally distributed residuals 
- `SD_s` is the standard deviation associated to site-level random effects

### Other distributions

#### Beta distribution

Note that the beta distribution does not allow for 0s or 1s. For this example, we replace those values with `0.001` and `0.999` respectively. 

```{r, echo = TRUE, warning=FALSE, message=FALSE, results='hide'}
Y_bray$diss2 <- ifelse(Y_bray$diss == 0, 0.001, Y_bray$diss)
Y_bray$diss2 <- ifelse(Y_bray$diss2 == 1, 0.999, Y_bray$diss2)

m_beta <- fit_gdum(Y = Y_bray$diss2, 
         W = doubs.env, 
         X = X, 
         D = D, 
         family = 'beta',
         link = 'logit',
         diss_formula = ~ s_dist_nit,
         site_formula = ~ s_pH,
         warmup = 2000,
         n_samples = 4000,
         Lmin = 15,
         Lmax = 20)
```

```{r}
summary(m_beta$draws)[[1]][1:5,]
```

Instead of `sigma`, `phi` is the scale parameter of the beta distribution. The larger the value of `phi`, the narrower the distribution gets around the estimated dissimilarity. 

#### Binomial distribution

The binomial distribution can be used when the dissimilarity index corresponds to a proportion of shared and unshared items, such as the Sørensen–Dice, Jaccard or Bray-Curtis dissimilarity indices. Both the numerator and the denominator need to be supplied independently:

```{r, echo = TRUE, warning=FALSE, message=FALSE, results='hide'}
m_bin <- fit_gdum(Y = Y_bin$num_sor, # Dissimilarity (numerator: b + c)
         Y_den = Y_bin$den_sor,     # Dissimilarity (denominator: 2a + b + c)
         W = doubs.env, # Site level predictors
         X = X, # Pairwise level predictors
         D = D, # Design matrix 
         family = 'binomial',
         link = 'logit',
         diss_formula = ~ s_dist_nit,
         site_formula = ~ s_pH,
         warmup = 2000,
         n_samples = 4000,
         Lmin = 10,
         Lmax = 15)
```

```{r}
summary(m_bin$draws)[[1]][1:4,]
```

The binomial distribution does not contain any scale parameter.

#### Beta binomial distribution

The beta-binomial distribution can be useful when the data is overdispersed compared to the binomial distribution.

```{r}
m_bbin <- fit_gdum(Y = Y_bin$num_sor, # Dissimilarity matrix (numerator: b + c)
         Y_den = Y_bin$den_sor,     
         W = doubs.env, # Site level predictors
         X = X, # Pairwise level predictors
         D = D, # Design matrix 
         family = 'betabinomial',
         link = 'logit',
         diss_formula = ~ s_dist_nit,
         site_formula = ~ s_pH,
         warmup = 2000,
         n_samples = 4000,
         Lmin = 10,
         Lmax = 15)
bayesplot::mcmc_trace(m_bbin$draws, regex_pars = c('alpha','beta','lambda'))
```

```{r}
summary(m_bbin$draws)[[1]][1:5,]
```


## Predictions and partial effects
### Assessing compositional uniqueness 

Community uniqueness (u) values, [equivalent to $SS_i$ in the computation of LCBD](https://doi.org/10.1111/ele.12141), can be obtained from the fitted model using the `predict_gdum()` function.

```{r}
u_pred <- predict_gdum(m_gaus, response = 'uniqueness')
```

We can compare those with the ones obtained with `adespatial::` and map the values across the river:
```{r}
u_pred <- data.frame(u_pred, lcbd = adespatial::LCBD.comp(vegan::vegdist(log1p(doubs.spe)))$LCBD)
```

```{r}
ggplot(u_pred, aes(x = lcbd, y = `X50.`/sum(`X50.`))) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  coord_equal() + 
  geom_abline(lty = 5) +
  ylab('u/sum(u) (GDUM)') +
  xlab('LCBD (adespatial)') +
  geom_linerange(aes(ymax = `X97.5.`/sum(`X50.`), ymin = `X2.5.`/sum(`X50.`)), linewidth = 1, col = 'lightblue') +
  geom_linerange(aes(ymax = `X75.`/sum(`X50.`), ymin = `X25.`/sum(`X50.`)), linewidth = 2, col = 'steelblue4') + 
  geom_point(shape = 21, fill = 'white', size = 2)

```


```{r}
ggplot(cbind(u_pred, doubs.spa) ,aes( x = x, y = y)) + 
  theme_void() +
  coord_equal() +
  geom_path() + 
  geom_point(shape = 21, aes(size = X50.), fill = 'steelblue') +
  scale_size_continuous('u_i', range = c(1,7))
```

Similarly, we can obtain the expected $u$ values when the site-level random effect is set to 0, indicating the expected site uniqueness given the combination of predictors in each site. 

```{r}
u_pred <- predict_gdum(m_gaus, response = 'uniqueness', re = FALSE)
u_pred <- data.frame(u_pred)
ggplot(cbind(u_pred, doubs.spa) ,aes( x = x, y = y)) + 
  theme_void() +
  coord_equal() +
  geom_path() + 
  geom_point(shape = 21, aes(size = X50.), fill = 'darkorange') +
  scale_size_continuous('u_i', range = c(1,7))

```

We can also control for nitrogen concentration (`s_dist_nit`) to asses the importance of this pairwise variable in determining uniqueness.

```{r}
u_pred <- predict_gdum(m_gaus, response = 'uniqueness', D_new = D, W_new = doubs.env, re = TRUE) 
u_pred <- data.frame(u_pred)
ggplot(cbind(u_pred, doubs.spa) ,aes( x = x, y = y)) + 
  theme_void() +
  coord_equal() +
  geom_path() + 
  geom_point(shape = 21, aes(size = X50.), fill = 'darkorange') +
  scale_size_continuous('u_i', range = c(1,7))

```

### Predict with new data

It is often useful to visualize the effect of individual predictors. This can also be achieved with `predict_gdum()`.

```{r}
# generate new data
n = 50
D_new <- t(combn(n, 2)) # n pairwise combinations
X_new <- data.frame(s_dist_nit = seq(min(X$s_dist_nit), 
                                     max(X$s_dist_nit), 
                                     length.out = nrow(D_new))) # Simulate pairwise predictors
W_new <- data.frame(s_pH = rep(mean(doubs.env$s_pH), n)) # Simulate site-level predictor

# Make predictions
pred <- predict_gdum(fit = m_bbin, X_new = X_new, W_new = W_new, D_new = D_new, 
                     re =FALSE, samples = 5000)
ggplot(cbind(pred, X_new), aes(x = s_dist_nit,y = `50%`)) +
  theme_bw() + 
  ylab('expected dissimilarity') + 
  geom_ribbon(aes(ymin = `2.5%`,max = `97.5%`), fill = 'lightblue', alpha = 0.5) + 
  geom_ribbon(aes(ymin = `25%`,max = `75%`), fill = 'steelblue4', alpha = 0.5) + 
  geom_line(colour = 'white', linewidth = 1.5) +
  geom_line()
```


```{r}
# generate new data
n = 50
D_new <- t(combn(n, 2)) # n pairwise combinations
X_new <- data.frame(s_dist_nit = rep(mean(doubs.env$s_pH),
                                     length.out = nrow(D_new))) # Simulate pairwise predictors
W_new <- data.frame(s_pH = seq(min(doubs.env$s_pH),max(doubs.env$s_pH), length.out = n)) # Simulate site-level predictor

# Make predictions
pred <- predict_gdum(fit = m_bbin, X_new = X_new, W_new = W_new, D_new = D_new, 
                     re = FALSE, samples = 5000, response = 'uniqueness')

ggplot(cbind(pred, W_new), aes(x = s_pH,y = `50%`)) +
  theme_bw() + 
  ylab('expected uniqueness (u_i)') + 
  geom_ribbon(aes(ymin = `2.5%`,max = `97.5%`), fill = 'lightblue', alpha = 0.5) + 
  geom_ribbon(aes(ymin = `25%`,max = `75%`), fill = 'steelblue4', alpha = 0.5) + 
  geom_line(colour = 'white', linewidth = 1.5) +
  geom_line()
  
```























































